#+SEQ_TODO: MAYBE TODO IN_PROGRESS | DONE

* Граничные условия на тело
** Как у нас
   Считаем время до соударения с плоскостью. Если оно положительная,
   то точка ещё не долетела. Если отрицательное, то перелёт — нужно
   вернуть точку в место столкновения и вместо отлёта внутрь за
   плоскость вернуть её наружу, обратив вдоль нормали вектор скорости.
   Время домножается на _знак скалярного произведения_ между вектором
   скорости молекулы и нормалью к поверхности (в противном случае
   отскочившая частица будет считаться вновь попавшей в поверхность
   уже с другой стороны — надо учитывать ориентацию плоскости).
   
   *Главный инвариант алгоритма* (который нам хотелось бы
    поддерживать): никакая точка не может быть углублена в тело более,
    чем на v*dt.
*** Композиции
    По расположению и вектору скорости всякой частицы строим прямую.
    Находим пересечения этой прямой со всеми элементами тела. Выбираем
    первое пересечение, попадающее в интервал [-dt;0].

    Часть траектории частицы, лежащая внутри какого-либо объекта,
    обозначается отрезком на действительной прямой (для
    полупространства — лучом). Полученная структура называется Trace и
    является списком таких отрезков.

    Trace пересечения объектов — пересечение Trace. Аналогично для
    объединения и дополнения. Для границ отрезков также указаны
    нормали соответствующей поверхности в точке возможного соударения.
    При выполнении операции дополнения эти нормали домножаются на -1.
**** [/] Проблемы
     - [ ] Возможен отскок внутрь соседствующего тела. Если делать
       после hit проверку на ещё одно соударение, есть вероятность
       зацикливания (если мы попали точно /встык/ пластин)

       *Решение*: удаляем все частицы, оставшиеся в теле после шага
       hit. Медленно. А что поделать?

     - [ ] Не бывает ли t в [-dt;0], когда частица вне тела (т. е.
       вектор скорости и нормаль дают положительное скалярное
       произведение). После отскока этого не случится, т.к. за
       отскоком последует шаг move.

       *Решение*: _бывает_, когда первоначальное соударение случилось
       с нулевым заглублением (то есть частица попала точь-в-точь на
       плоскость). Тогда удаляясь после отскока, она переходит на
       расстояние точно dt*v от тела, что приводит к определению
       нового (уже ложного) соударения и возвращает частицу внутрь
       тела. Затем она углубляется на шаге move ещё глубже в тело, и
       очередная проверка столкновения натыкается на нарушенный
       инвариант.

       Что делать?
       1. Проверять угол между скоростью и нормалью. Удовлетворять
          условию будет лишь малое число частиц и очень редко. Медленно.

       2. Вносить малый ε-шум в положение частицы после отскока.
          Похожая техника позволит избавиться от необходимости делать
          collapsePoint (правильное пересечение отрезков в случае,
          когда результатом является одна точка — при точном
          попадании).

     - [ ] Иногда появляется частица, скользящая вдоль плоскости. Нормаль
       перпендикулярна скорости, поэтому она никуда не отскакивает.
       При этом она может пролетать сквозь другие тела!

*** TODO [1/2] Добавить тела
    - [X] конус
    - [ ] парабола

*** TODO Разобраться с normal для цилиндра
    Почему-то нужно normalize (хотя вроде по формулам уже должна
    получаться единичная длина)
** Bird
** Закиров
   Строим пересечение луча и кривой второго порядка, получая две точки
   t (время соударения). Если t ≥ eps (отсечка отрицательных корней),
   то был удар. Закиров не учитывает соударения частиц до подлёта к
   телу, поэтому можно сразу построить прямую и найти для неё точку
   удара. В таком подходе нет итерирования по времени вообще, точки
   как бы сразу долетают до тела.
** Как ускорить и улучшить
   - для тел вводить упрощённый описывающий объём и сначала проверять,
     попала ли точка в него;
   - разбивать пространство через octree;
   - разбивать пространство на адаптивную сетку (также полезно для
     соударений) и проверять на удары только с поверхностями,
     попавшими в ячейку сетки
* Отрисовка тел
** Как отрисовывать

*** Трассировка лучей
    Используем тот же код. По вектору нормали плоскости просмотра строим
    координатную систему, в которой генерируем нужное количество точек
    по X, Y в заданной плоскости, после чего направляем их вдоль нормали
    этой плоскости (на тело). Если соударений нет, то пиксель имеет цвет
    фона. Иначе — определённый цвет тела. Можно учитывать нормаль к телу
    в точке пересечения, точечные источники и т.

    Use REPA: http://code.ouroborus.net/gloss/gloss-head/gloss-examples/Ray/

**** TODO Исправить функцию buildCartesian
     Не работает при x, y = 0
*** Marching Cubes
    Тесселизация скалярного поля (у нас бинарного) как бы. Требуется
    только insideBody!
         
*** Сторонние библиотеки
    1. OpenSCAD только моделирование, использует OpenCSG.
    2. OpenCASCADE может также показать результаты (CSG не напрямую).
    3. Своё приложение + OpenCSG.
** Посмотреть проекты
   - http://opencsg.org/ — библиотека для рендера CSG;
   - http://www.nigels.com/research/ — о рендере CSG;
   - http://www.openscad.org/ — создание CSG-моделей;
   - http://gts.sourceforge.net/ — GNU Triangulated Surface (операции
     над поверхностями);

* Оптимизации
  http://www.haskell.org/haskellwiki/Performance/GHC
** Параллелизм
   
*** IN_PROGRESS Как семплировать макропараметры
    В каждой ячейке может быть разное количество частиц, поэтому для
    использования Repa или Accelerate придётся дополнить разреженную матрицу до
    плотной по самой жирной ячейке. Можно оказаться без памяти (в
    худшем (невероятном) случае N=1e6, Nc=1000 и имеем 1e9 элементов
    массива — память треснет).

    С репой можно было бы вычисление макропараметров делать как
    свёртка по внутреннему измерению. А так придётся parMap.

    Вместо разреженной матрицы из `V.Vector (VU.Vector Particle)`
    используем плотную упаковку ячеек друг за другом в одном большом
    массиве `VU.Vector Particle`. Тесты показывают, что дольше всего
    выполняется копирование частиц в итоговый отсортированный массив.
    Поэтому целесообразно это копирование делать параллельно с помощью
    computeP + fromFunction. Для этого нужно знать положение каждой
    частицы в целевом массиве, для чего:

    1. нужно сначала классифицировать все частицы (параллельно) —
       classes
    
    2. рассчитать количество частиц в каждой ячейке и положения частиц
       в ячейках (последовательно) — lengths и posns

    3. использовать эту информацию для определения смещений
       (последовательно) первого элемента каждой ячейке в итоговом
       массиве (первого индекса ячейки в нём) — starts

    4. зная смещения ячеек и номер частицы в ячейке, можно определить
       точное положение частицы в финальном массиве и построить
       обратный индекс (последовательно) — sortedIds

    5. Дальше копирование (параллельно).

    Тесты показывают, что на 6КК частиц и 64К ячеек при параллельном
    копировании суммарное времени работы sortParticles составляет
    ~0.6s против старого результата ~1.4s при последовательном
    копировании.

    starts не забываем (чтобы знать, где какая ячейка начинается в
    большом массиве).

    Параллельная классификация даёт прироста производительности: 0.04s
    против 0.15s (по времени работы classifyAll — но тут нужно учесть,
    что реповая классификация только вычисляет индексы, а
    последовательная при этом ещё и смещения сразу определяет).

*** DONE openBoundaryInjection
    CLOSED: [2012-06-05 Вт. 13:57]
    Шесть подобластей можно наполнять данными параллельно!

*** TODO Repa unsafe
    Перейти на реповые комбинаторы, которые не выполняют проверки
    границ.
** Типы
  http://www.haskell.org/haskellwiki/Performance/Datatypes   
*** DONE Быстрые вектора
    CLOSED: [2012-06-06 Ср. 21:29]
    Строгие типы + unboxing

    Для Unbox a использовали Tuple (со своим строгим вектором
    получается <<loop>>?). С одной стороны, Unbox. С другой стороны,
    не будет ли ребоксинга на листочках?

    A single-constructor datatype can be unpacked when it is passed to
    a strict function.
    
    Роман сказал, что следует надеяться на GHC и отсутствие
    ребоксинга.
*** MAYBE Traceables
    - improve uniteTraces & intersectTraces
      
    - a different type for HitSegment? Not tuples but custom datatype
      with unboxed values. — как и для векторов
** MAYBE -optc-ffast-math
   Can't use straight away now since we use infinityP/infinityN
** IN_PROGRESS Export lists

   For best results, use an explicit export list. If you do, GHC can
   inline any non-exported functions that are only called once, even
   if they are very big. Without an explicit export list, GHC must
   assume that every function is exported, and hence (to avoid code
   bloat) is more conservative about inlining.
   
* Интеграция
** Haskell-библиотека Implicit (CSG)
   https://github.com/colah/ImplicitCAD

   Ориентируется на тесселизацию тел (не усрётся ли столкновительный
   движок от полигональной модели? в SMILE делали так).
   
* Прочие задачи

** TODO Typesafe cell indexing
   (Int -> Point), Classifier и размер сетки должны проверяться на
   уровне типов.
** DONE Выполнять предварительную обработку тел
   CLOSED: [2012-07-02 Пн. 15:12]
   - [X] force normalization for normal vectors
** DONE Domain implementation
   CLOSED: [2012-06-05 Вт. 01:30]
   Use message-passing instead of pattern-matching?

* Граничные условия на тело
** Как у нас
   Считаем время до соударения с плоскостью. Если оно положительная,
   то точка ещё не долетела. Если отрицательное, то перелёт — нужно
   вернуть точку в место столкновения и вместо отлёта внутрь за
   плоскость вернуть её наружу, обратив вдоль нормали вектор скорости.
   Время домножается на _знак скалярного произведения_ между вектором
   скорости молекулы и нормалью к поверхности (в противном случае
   отскочившая частица будет считаться вновь попавшей в поверхность
   уже с другой стороны — надо учитывать ориентацию плоскости).
*** Композиции                                                     :OBSOLETE:
    *Пересечение*: вычисляем время до удара с каждой поверхностью. Если
    они все отрицательные (пролетели внутрь *каждой*), вычисляем из
    них минимальное, для соответствующей поверхности делаем отскок и
    обращаем скорость от неё.
    *Объединение*: смотрим, пролетелил ли мы внутрь *хотя бы одной*,
    вычисляем *максимальное время* (в какую успели глубже всего
    погрузиться), отскок от соответствующей.
    *Дополнение*: 
*** Композиции
    По расположению и вектору скорости всякой частицы строим прямую.
    Находим пересечения этой прямой со всеми элементами тела. Выбираем
    первое пересечение, попадающее в интервал [-dt;0].

    Часть траектории частицы, лежащая внутри какого-либо объекта,
    обозначается отрезком на действительной прямой (для
    полупространства — лучом). Полученная структура называется Trace и
    является списком таких отрезков.

    Trace пересечения объектов — пересечение Trace. Аналогично для
    объединения и дополнения. Для границ отрезков также указаны
    нормали соответствующей поверхности в точке возможного соударения.
    При выполнении операции дополнения эти нормали домножаются на -1.
**** [/] Проблемы
     - [ ] Возможен отскок внутрь соседствующего тела. Если делать
       после hit проверку на ещё одно соударение, есть вероятность
       зацикливания (если мы попали точно встык пластин)

       *Решение*: удаляем все частицы, оставшиеся в теле после шага
       hit.
     - [ ] Не бывает ли t в [-dt;0], когда частица вне тела (т. е.
       вектор скорости и нормаль дают положительное скалярное
       произведение). После отскока этого не случится, т.к. за
       отскоком последует шаг move.

     - [ ] Иногда появляется частица, скользящая вдоль плоскости. Нормаль
       перпендикулярна скорости, поэтому она никуда не отскакивает.
       При этом она может пролетать сквозь другие тела!

*** TODO [0/2] Добавить тела
    - [ ] конус
    - [ ] парабола
** Bird
** Закиров
   Строим пересечение луча и кривой второго порядка, получая две точки
   t (время соударения). Если t ≥ eps (отсечка отрицательных корней),
   то был удар. Закиров не учитывает соударения частиц до подлёта к
   телу, поэтому можно сразу построить прямую и найти для неё точку
   удара. В таком подходе нет итерирования по времени вообще, точки
   как бы сразу долетают до тела.
** Как ускорить и улучшить
   - для тел вводить упрощённый описывающий объём и сначала проверять,
     попала ли точка в него;
   - разбивать пространство через octree;
   - разбивать пространство на адаптивную сетку (также полезно для
     соударений) и проверять на удары только с поверхностями,
     попавшими в ячейку сетки
* Отрисовка тел
  
** Как отрисовывать

*** Трассировка лучей
    Используем тот же код. По вектору нормали плоскости просмотра строим
    координатную систему, в которой генерируем нужное количество точек
    по X, Y в заданной плоскости, после чего направляем их вдоль нормали
    этой плоскости (на тело). Если соударений нет, то пиксель имеет цвет
    фона. Иначе — определённый цвет тела. Можно учитывать нормаль к телу
    в точке пересечения, точечные источники и т.

**** TODO Исправить функцию buildCartesian
     Не работает при x, y = 0
*** Marching Cubes
    Тесселизация скалярного поля как бы. Требуется только insideBody.
*** OpenGL
    См. работу Nigel Stewart.

    CSG rendering can be regarded as two sub-problems: clipping and
    visible surface determination.

    *Алгоритм Голдфизера:*

    1. Дерево должно быть нормализовано (приведено в вид объединения
       произведений. В произведение могут входить примитивы и их
       дополнения).
    2. Отрисовываем каждое произведение во временный z-buffer, после
       чего выводим все буферы последовательно (корректная отрисовка
       объединения выполняется средствами OpenGL с помощью проверки
       глубины каждой точки — тривиально).
    3. В каждом произведении всякий его элемент «сужается» на прочие
       объекты следующим образом.

       a. Рисуем сужаемый элемент в буфер глубины. Удаляем задние
       грани (либо передние, если нужно объект взят с дополнением).
       
       b. Отключив тест глубины, рисуем прочие объекты. В буфере
       трафарета обращаем значение пикселя для всякого фрагмента
       (удаление граней отключено). Как бы считаем, сколько раз нужно
       пересечь другие поверхности, чтобы долететь до тела. Раз все
       примитивы выпуклые, то внутренние точки пересечения достигаются
       за нечётное количество пересечений (влетели и ещё не вылетели).

       c. Рисуем сужаемый элемент уже по-настоящему, удаляя задние
       грани. В трафарете учитываем только нечётные (равные 1) пиксели
       (либо чётные, если объект вычитался из сужаемого). Как сужать:
       поставить depthRange в 1.0-1.0, рисуем плоскость во весь экран
       с нужным тестом по трафарету, так что часть пикселей исходной
       поверхности уходит в Zf. Повторяем операцию после рисовки
       каждого сужающего объекта. Так работает OpenCSG. 

       Потом нужно как-то проверить

     Нужно сохранять/восстанавливать содержимое z-buffer:
       - glBlitFramebuffer;

       - PBO
         
*** Сторонние библиотеки
    1. OpenSCAD только моделирование, использует OpenCSG.
    2. OpenCASCADE может также показать результаты (CSG не напрямую).
    3. Своё приложение + OpenCSG.
** На чём отрисовывать
*** PGM
    Очень простой формат изображения
*** GLUT
    Непонятная координатная система: (x, y) точки не соответствуют
    пикселям окна рисования.
*** Pixbuf/drawingarea
    Надо рисовать поточечно?
** Посмотреть проекты
   - http://opencsg.org/ — библиотека для рендера CSG;
   - http://www.nigels.com/research/ — о рендере CSG;
   - http://www.openscad.org/ — создание CSG-моделей;
   - http://gts.sourceforge.net/ — GNU Triangulated Surface (операции
     над поверхностями);
* OpenGL
  
** Освещение
#+BEGIN_SRC haskell
  -- Отдельный источник (ambient, diffuse и т.д.)
  ambient light0 $= lightColor
  position light0 $= lightPosition
  light light0 $= Enabled
  
  -- Включить освещение
  lighting $= Enabled
  
  -- Общий фоновый свет
  lightModelAmbient $= lightColor
#+END_SRC

** Включение отсечки по глубине
#+BEGIN_SRC haskell
  depthFunc $= Just Lequal
#+END_SRC

** Установка камеры
#+BEGIN_SRC haskell
  lookAt (Vertex3 0.0 0.0 5.0) (Vertex3 0.0 0.0 0.0) (Vector3 0.0 1.0 0.0)
  lookAt eye lookto up
#+END_SRC

** Трафаретный буфер
   stencilFunc (f, ref, mask) задаёт условие прохождения трафаретного
   теста. stencilOp задаёт преобразование соответствующей точки
   буфера.
   Плюс надо включить: stencilTest $= Enabled.
   Очистка: clear [StencilBuffer].
   При инициализации: [WithStencilBuffer]

* Макроскопические параметры
** Подход
   Разбиваем пространство на множество ячеек (возможно пересекающихся,
   если используются сферы), вычисляем значение параметра, осредняя
   частные значения по всем частицам в ячейке.
* Направления оптимизации

** TODO solveq

** TODO Мемоизация результатов processParticle
   Частица может попасть в несколько ячеек при вычислении
   макроскопических параметров (без мемоизации замедляется).
* GUI
  Интерфейс должен позволять задание параметров набегающего потока,
  геометрии тела, запуск расчёта и просмотр результатов.
* Поддержка
  Haskell-библиотека Implicit (CSG)

#+SEQ_TODO: MAYBE TODO IN_PROGRESS | DONE

* Граничные условия на тело
** Как у нас
   Считаем время до соударения с плоскостью. Если оно положительная,
   то точка ещё не долетела. Если отрицательное, то перелёт — нужно
   вернуть точку в место столкновения и вместо отлёта внутрь за
   плоскость вернуть её наружу, обратив вдоль нормали вектор скорости.
   Время домножается на _знак скалярного произведения_ между вектором
   скорости молекулы и нормалью к поверхности (в противном случае
   отскочившая частица будет считаться вновь попавшей в поверхность
   уже с другой стороны — надо учитывать ориентацию плоскости).
   
   *Главный инвариант алгоритма* (который нам хотелось бы
    поддерживать): никакая точка не может быть углублена в тело более,
    чем на v*dt.

*** Композиции                                                     :OBSOLETE:
    *Пересечение*: вычисляем время до удара с каждой поверхностью. Если
    они все отрицательные (пролетели внутрь *каждой*), вычисляем из
    них минимальное, для соответствующей поверхности делаем отскок и
    обращаем скорость от неё.
    *Объединение*: смотрим, пролетелил ли мы внутрь *хотя бы одной*,
    вычисляем *максимальное время* (в какую успели глубже всего
    погрузиться), отскок от соответствующей.
    *Дополнение*: 
*** Композиции
    По расположению и вектору скорости всякой частицы строим прямую.
    Находим пересечения этой прямой со всеми элементами тела. Выбираем
    первое пересечение, попадающее в интервал [-dt;0].

    Часть траектории частицы, лежащая внутри какого-либо объекта,
    обозначается отрезком на действительной прямой (для
    полупространства — лучом). Полученная структура называется Trace и
    является списком таких отрезков.

    Trace пересечения объектов — пересечение Trace. Аналогично для
    объединения и дополнения. Для границ отрезков также указаны
    нормали соответствующей поверхности в точке возможного соударения.
    При выполнении операции дополнения эти нормали домножаются на -1.
**** [/] Проблемы
     - [ ] Возможен отскок внутрь соседствующего тела. Если делать
       после hit проверку на ещё одно соударение, есть вероятность
       зацикливания (если мы попали точно /встык/ пластин)

       *Решение*: удаляем все частицы, оставшиеся в теле после шага
       hit. Медленно. А что поделать?

     - [ ] Не бывает ли t в [-dt;0], когда частица вне тела (т. е.
       вектор скорости и нормаль дают положительное скалярное
       произведение). После отскока этого не случится, т.к. за
       отскоком последует шаг move.

       *Решение*: _бывает_, когда первоначальное соударение случилось
       с нулевым заглублением (то есть частица попала точь-в-точь на
       плоскость). Тогда удаляясь после отскока, она переходит на
       расстояние точно dt*v от тела, что приводит к определению
       нового (уже ложного) соударения и возвращает частицу внутрь
       тела. Затем она углубляется на шаге move ещё глубже в тело, и
       очередная проверка столкновения натыкается на нарушенный
       инвариант.

       Что делать?
       1. Проверять угол между скоростью и нормалью. Удовлетворять
          условию будет лишь малое число частиц и очень редко. Медленно.

       2. Вносить малый ε-шум в положение частицы после отскока.
          Похожая техника позволит избавиться от необходимости делать
          collapsePoint (правильное пересечение отрезков в случае,
          когда результатом является одна точка — при точном
          попадании).

     - [ ] Иногда появляется частица, скользящая вдоль плоскости. Нормаль
       перпендикулярна скорости, поэтому она никуда не отскакивает.
       При этом она может пролетать сквозь другие тела!

*** TODO [0/2] Добавить тела
    - [ ] конус
    - [ ] парабола

*** TODO Разобраться с normal для цилиндра
    Почему-то нужно normalize (хотя вроде по формулам уже должна
    получаться единичная длина)
** Bird
** Закиров
   Строим пересечение луча и кривой второго порядка, получая две точки
   t (время соударения). Если t ≥ eps (отсечка отрицательных корней),
   то был удар. Закиров не учитывает соударения частиц до подлёта к
   телу, поэтому можно сразу построить прямую и найти для неё точку
   удара. В таком подходе нет итерирования по времени вообще, точки
   как бы сразу долетают до тела.
** Как ускорить и улучшить
   - для тел вводить упрощённый описывающий объём и сначала проверять,
     попала ли точка в него;
   - разбивать пространство через octree;
   - разбивать пространство на адаптивную сетку (также полезно для
     соударений) и проверять на удары только с поверхностями,
     попавшими в ячейку сетки
* Отрисовка тел
** Как отрисовывать

*** Трассировка лучей
    Используем тот же код. По вектору нормали плоскости просмотра строим
    координатную систему, в которой генерируем нужное количество точек
    по X, Y в заданной плоскости, после чего направляем их вдоль нормали
    этой плоскости (на тело). Если соударений нет, то пиксель имеет цвет
    фона. Иначе — определённый цвет тела. Можно учитывать нормаль к телу
    в точке пересечения, точечные источники и т.

    Use REPA: http://code.ouroborus.net/gloss/gloss-head/gloss-examples/Ray/

**** TODO Исправить функцию buildCartesian
     Не работает при x, y = 0
*** Marching Cubes
    Тесселизация скалярного поля (у нас бинарного) как бы. Требуется
    только insideBody!
*** OpenGL
    См. работу Nigel Stewart.

    CSG rendering can be regarded as two sub-problems: clipping and
    visible surface determination.

    *Алгоритм Голдфизера:*

    1. Дерево должно быть нормализовано (приведено в вид объединения
       произведений. В произведение могут входить примитивы и их
       дополнения).
    2. Отрисовываем каждое произведение во временный z-buffer, после
       чего выводим все буферы последовательно (корректная отрисовка
       объединения выполняется средствами OpenGL с помощью проверки
       глубины каждой точки — тривиально).
    3. В каждом произведении всякий его элемент «сужается» на прочие
       объекты следующим образом.

       a. Рисуем сужаемый элемент в буфер глубины. Удаляем задние
       грани (либо передние, если нужно объект взят с дополнением).
       
       b. Отключив тест глубины, рисуем прочие объекты. В буфере
       трафарета обращаем значение пикселя для всякого фрагмента
       (удаление граней отключено). Как бы считаем, сколько раз нужно
       пересечь другие поверхности, чтобы долететь до тела. Раз все
       примитивы выпуклые, то внутренние точки пересечения достигаются
       за нечётное количество пересечений (влетели и ещё не вылетели).

       c. Рисуем сужаемый элемент уже по-настоящему, удаляя задние
       грани. В трафарете учитываем только нечётные (равные 1) пиксели
       (либо чётные, если объект вычитался из сужаемого). Как сужать:
       поставить depthRange в 1.0-1.0, рисуем плоскость во весь экран
       с нужным тестом по трафарету, так что часть пикселей исходной
       поверхности уходит в Zf. Повторяем операцию после рисовки
       каждого сужающего объекта. Так работает OpenCSG. 

       Потом нужно как-то проверить

     Нужно сохранять/восстанавливать содержимое z-buffer:
       - glBlitFramebuffer;

       - PBO
         
*** Сторонние библиотеки
    1. OpenSCAD только моделирование, использует OpenCSG.
    2. OpenCASCADE может также показать результаты (CSG не напрямую).
    3. Своё приложение + OpenCSG.
** На чём отрисовывать
*** PGM
    Очень простой формат изображения
*** GLUT
    Непонятная координатная система: (x, y) точки не соответствуют
    пикселям окна рисования.
*** Pixbuf/drawingarea
    Надо рисовать поточечно?
** Посмотреть проекты
   - http://opencsg.org/ — библиотека для рендера CSG;
   - http://www.nigels.com/research/ — о рендере CSG;
   - http://www.openscad.org/ — создание CSG-моделей;
   - http://gts.sourceforge.net/ — GNU Triangulated Surface (операции
     над поверхностями);
** OpenGL
   
*** Освещение
#+BEGIN_SRC haskell
  -- Отдельный источник (ambient, diffuse и т.д.)
  ambient light0 $= lightColor
  position light0 $= lightPosition
  light light0 $= Enabled
  
  -- Включить освещение
  lighting $= Enabled
  
  -- Общий фоновый свет
  lightModelAmbient $= lightColor
#+END_SRC

*** Включение отсечки по глубине
#+BEGIN_SRC haskell
  depthFunc $= Just Lequal
#+END_SRC

*** Установка камеры
#+BEGIN_SRC haskell
  lookAt (Vertex3 0.0 0.0 5.0) (Vertex3 0.0 0.0 0.0) (Vector3 0.0 1.0 0.0)
  lookAt eye lookto up
#+END_SRC

*** Трафаретный буфер
    stencilFunc (f, ref, mask) задаёт условие прохождения трафаретного
    теста. stencilOp задаёт преобразование соответствующей точки
    буфера.
    Плюс надо включить: stencilTest $= Enabled.
    Очистка: clear [StencilBuffer].
    При инициализации: [WithStencilBuffer]

* Оптимизации
  http://www.haskell.org/haskellwiki/Performance/GHC
** Параллелизм
   
*** TODO Как семплировать макропараметры
    В каждой ячейке может быть разное количество частиц, поэтому для
    использования Repa или Accelerate придётся дополнить разреженную матрицу до
    плотной по самой жирной ячейке. Можно оказаться без памяти (в
    худшем (невероятном) случае N=1e6, Nc=1000 и имеем 1e9 элементов
    массива — память треснет).

    С репой можно было бы вычисление макропараметров делать как
    свёртка по внутреннему измерению. А так придётся parMap.
*** DONE openBoundaryInjection
    CLOSED: [2012-06-05 Вт. 13:57]
    Шесть подобластей можно наполнять данными параллельно!

*** TODO Repa unsafe
    Перейти на реповые комбинаторы, которые не выполняют проверки
    границ.
** Типы
  http://www.haskell.org/haskellwiki/Performance/Datatypes   
*** DONE Быстрые вектора
    CLOSED: [2012-06-06 Ср. 21:29]
    Строгие типы + unboxing

    Для Unbox a использовали Tuple (со своим строгим вектором
    получается <<loop>>?). С одной стороны, Unbox. С другой стороны,
    не будет ли ребоксинга на листочках?

    A single-constructor datatype can be unpacked when it is passed to
    a strict function.
    
    Роман сказал, что следует надеяться на GHC и отсутствие
    ребоксинга.
*** MAYBE Traceables
    - improve uniteTraces & intersectTraces
      
    - a different type for HitSegment? Not tuples but custom datatype
      with unboxed values. — как и для векторов
** MAYBE -optc-ffast-math
   Can't use straight away now since we use infinityP/infinityN
** IN_PROGRESS Export lists

   For best results, use an explicit export list. If you do, GHC can
   inline any non-exported functions that are only called once, even
   if they are very big. Without an explicit export list, GHC must
   assume that every function is exported, and hence (to avoid code
   bloat) is more conservative about inlining.
   
* Интеграция
** Haskell-библиотека Implicit (CSG)
   https://github.com/colah/ImplicitCAD

   Ориентируется на тесселизацию тел (не усрётся ли столкновительный
   движок от полигональной модели? в SMILE делали так).
   
* Прочие задачи

** TODO Typesafe cell indexing
   (Int -> Point), Classifier и размер сетки должны проверяться на
   уровне типов.
** TODO Выполнять предварительную обработку тел
   - [ ] force normalization for normal vectors
** DONE Domain implementation
   CLOSED: [2012-06-05 Вт. 01:30]
   Use message-passing instead of pattern-matching?
